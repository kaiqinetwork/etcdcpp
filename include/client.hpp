#ifndef __ETCD_CLIENT_HPP_INCLUDED__
#define __ETCD_CLIENT_HPP_INCLUDED__

#include "internal/curl.hpp"
#include <map>
#include <memory>
#include <string>

namespace etcd {

//----------------------------- EXCEPTIONS ----------------------------------

/**
 * @brief Exception generated by etcd client
 */
struct ClientException : public std::runtime_error {
    ClientException(const std::string& error)
       :std::runtime_error("etcd unknown exception"),
        error(error)
      {}

    virtual const char* what() const throw() {
        return error.c_str();
    }

    std::string error;
};

/**
 * @brief Exception generated by etcd. The json wrapper throws an exception
 * based on whether etcd returned an error
 */
struct ReplyException : public std::runtime_error {
    ReplyException(int error_code,
                  const std::string& msg,
                  const std::string& cause)
       :std::runtime_error("etcd exception"),
        cause(cause),
        error_code(error_code),
        msg(msg)
      {}

    virtual const char* what() const throw() {
        std::ostringstream estr;
        estr << msg << "["<< error_code << "]: " << cause;
        return estr.str().c_str();
    }

    std::string cause;
    int error_code; 
    std::string msg;
};

// ---------------------------- TYPES ---------------------------------------

enum class Action {
    ACTION_SET,
	ACTION_GET,
	ACTION_DELETE,
	ACTION_UPDATE,
	ACTION_CREATE,
	ACTION_COMPARE_AND_SWAP,
	ACTION_COMPARE_AND_DELETE,
	ACTION_EXPIRE,
	ACTION_UNKNOWN
};

struct ResponseActionMap : public std::map<std::string, Action> {
    ResponseActionMap() {
		this->operator[]("set") = Action::ACTION_SET;
		this->operator[]("get") = Action::ACTION_GET;
		this->operator[]("delete") = Action::ACTION_DELETE;
		this->operator[]("update") = Action::ACTION_UPDATE;
		this->operator[]("create") = Action::ACTION_CREATE;
		this->operator[]("compareAndSwap") = Action::ACTION_COMPARE_AND_SWAP;
		this->operator[]("compareAndDelete") = Action::ACTION_COMPARE_AND_DELETE;
		this->operator[]("expire") = Action::ACTION_EXPIRE;
    }

    ~ResponseActionMap(){}
};


typedef uint16_t Port; 
typedef uint64_t Index;
typedef uint64_t TtlValue;

/**
 * @brief c++ language binding for an etcd curl client
 *
 * @tparam Reply see rapid_reply.hpp for an example Reply template. It should
 * be constructable using a std::string(json response).
 */
template <typename Reply>
class Client {
  public:
    // LIFECYCLE
    Client(const std::string& server, const Port& port);

    // OPERATIONS

    /**
     * @brief Set a key-value pair
     *
     * @param key full prefix of the key
     * @param value the value
     *
     * @return see etcd::Client @tparam
     */
    Reply Set(
        const std::string& key,
        const std::string& value);

    /**
     * @brief Set a key-value pair that expires after a certain number of
     * seconds.
     *
     * @param key full prefix of the key
     * @param value the value
     * @param ttl the time to live in seconds. key-value will expire immediately
     * if ttl is set to zero.
     *
     * @return see etcd::Client @tparam
     */
    Reply Set(
        const std::string& key,
        const std::string& value,
        const TtlValue& ttl);

    /**
     * @brief Url encode a given value
     *
     * @param value string to escape
     *
     * @return escaped string
     */
    std::string UrlEncode(const std::string& value);

    /**
     * @brief Url decode a given value
     *
     * @param value string to unescape
     *
     * @return unescaped string
     */
    std::string UrlDecode(const std::string& value);

    /**
     * @brief Clear the ttl on a key.
     *
     * @param key full prefix of the key
     * @param value the value
     *
     * @return see etcd::Client @tparam
     */
    Reply ClearTtl(
        const std::string& key,
        const std::string& value);

    /**
     * @brief Create an in-order key. etcd will create a sequential key inside
     * directory "dir" and associate it with value
     *
     * @param dir full prefix of the directory
     * @param value the value
     *
     * @return see etcd::Client @tparam
     */
    Reply SetOrdered(
        const std::string& dir,
        const std::string& value);

    /**
     * @brief Get the value of a key
     *
     * @param key full prefix of the key
     *
     * @return see etcd::Client @tparam
     */
    Reply Get(const std::string& key);

    /**
     * @brief Recursively get all the keys and directory rooted @ key
     *
     * @param key the key or directory to fetch
     *
     * @return see etcd::Client @tparam
     */
    Reply GetAll(const std::string& key);

    /**
     * @brief enumerate the in-order keys as a sorted list
     *
     * @param dir the directory which holds the in-order key
     *
     * @return see etcd::Client @tparam
     */
    Reply GetOrdered(const std::string& dir);

    /**
     * @brief Delete a key-value pair
     *
     * @param key the key or empty directory to delete
     *
     * @return see etcd::Client @tparam
     */
    Reply Delete(const std::string& key);

    /**
     * @brief Add a directory
     *
     * @param dir full prefix of the directory
     *
     * @return see etcd::Client @tparam
     */
    Reply AddDirectory(const std::string& dir);

    /**
     * @brief Add a direcotry that expires after ttl seconds
     *
     * @param dir full prefix name of directory to add
     * @param ttl expiry in seconds
     *
     * @return see etcd::Client @tparam
     */
    Reply AddDirectory(const std::string& dir, const TtlValue& ttl);

    /**
     * @brief Update the ttl of a directory. The directory can only be
     * updated with a specific ttl. Use clear_ttl to clear the ttl. A ttl
     * value of zero will expire the directory immediately
     *
     * @param dir full prefix name of the directory to delete
     * @param ttl expiry in seconds
     *
     * @return see etcd::Client @tparam
     */
    Reply UpdateDirectoryTtl(const std::string& dir, const TtlValue& ttl);

    /**
     * @brief Delete a directory and optionally its contents. If recursive is
     * false and the directory is not empty, it will throw an exception
     *
     * @param dir full prefix name of the directory
     * @param recursive flag to indicate whether we should delete child nodes.
     *
     * @return see etcd::Client @tparam
     */
    Reply DeleteDirectory(const std::string& dir, bool recursive = false);

    /**
     * @brief Atomic compare and swap if the previous value of key matches
     * a specified key
     *
     * @param key full prefix of the key to update
     * @param value new value of the key
     * @param prevValue existing value to check
     *
     * @return see etcd::Client @tparam
     */
    Reply CompareAndSwapIf(
        const std::string& key,
        const std::string& value,
        const std::string& prevValue);

    /**
     * @brief Atomically compare and swap a key if the specified previousIndex
     * matches the current modified index of the key
     *
     * @param key full prefix of the key to update
     * @param value new value of the key
     * @param prevIndex index to match with the modifiedIndex
     *
     * @return see etcd::Client @tparam
     */
    Reply CompareAndSwapIf(
        const std::string& key,
        const std::string& value,
        const Index& prevIndex);

    /**
     * @brief Atomically compare and swap a key based on whether it alreayd
     * exists or not
     *
     * @param key full prefix of the key to update
     * @param value new value
     * @param prevExist should the key already exist or not?
     *
     * @return see etcd::Client @tparam
     */
    Reply CompareAndSwapIf(
        const std::string& key,
        const std::string& value,
        bool prevExist);

    /**
     * @brief Atomically compare and delete a key
     *
     * @param key full prefix of the key to delete
     * @param prevValue only delete the key if the value matches this field
     *
     * @return see etcd::Client @tparam
     */
    Reply CompareAndDeleteIf(
        const std::string& key,
        const std::string& prevValue);

    /**
     * @brief Atomically compare and delete a key if the current modified
     * index is equal to the passed index
     *
     * @param key full prefix of the key to delete
     * @param prevIndex only delete if the modifiedIndex is equal to this field
     *
     * @return see etcd::Client @tparam
     */
    Reply CompareAndDeleteIf(
        const std::string& key,
        const Index& prevIndex);

  private:
    // CONSTANTS
    const char *kPutRequest = "PUT";
    const char *kPostRequest = "POST";
    const char *kDeleteRequest = "DELETE";

    const char *kValue = "value";
    const char *kTttl = "ttl";
    const char *kDir = "dir";
    const char *kPrevExist = "prevExist";
    const char *kPrevIndex = "prevIndex";
    const char *kPrevValue = "prevValue";
    const char *kSortedSuffix = "?recursive=true&sorted=true";

    // DATA
    bool enable_header_;
    std::string url_;
    std::string url_prefix_;
    std::unique_ptr<internal::Curl> handle_;

    // OPERATIONS
    Reply _GetReply(const std::string& json);
};

//------------------------------- LIFECYCLE ----------------------------------

template <typename Reply> Client<Reply>::
Client(const std::string& server, const Port& port)
try:
    handle_(new internal::Curl()) {
    std::ostringstream ostr;
    ostr << "http://" << server << ":" << port; 
    url_ = ostr.str();
    ostr << "/v2/keys/";
    url_prefix_ = ostr.str();
} catch (const std::exception& e) {
    throw ClientException(e.what());
}

//------------------------------- OPERATIONS ---------------------------------
template <typename Reply> Reply Client<Reply>::
Set(const std::string& key, const std::string& value) {
    std::string ret;
    try {
        ret = handle_->Set(url_prefix_ + key, kPutRequest, {{kValue, value}});
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

template <typename Reply> Reply Client<Reply>::
Set(const std::string& key,
    const std::string& value,
    const TtlValue& ttl) {
    std::string ret;
    try {
        ret = handle_->Set(url_prefix_ + key, kPutRequest,
            {
                {kValue, value},
                {kTttl, std::to_string(ttl)},
            });
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

template <typename Reply> Reply Client<Reply>::
ClearTtl(const std::string& key, const std::string& value) {
    std::string ret;
    try {
        ret = handle_->Set(url_prefix_ + key, kPutRequest,
            {
                {kValue, value},
                {kTttl, ""},
                {kPrevExist, "true"}
            });
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

template <typename Reply> std::string Client<Reply>::
UrlEncode(const std::string& value) {
    return handle_->UrlEncode(value);
}

template <typename Reply> std::string Client<Reply>::
UrlDecode(const std::string& value) {
    return handle_->UrlDecode(value);
}

template <typename Reply> Reply Client<Reply>::
SetOrdered(const std::string& dir, const std::string& value) {
    std::string ret;
    try {
        ret = handle_->Set(url_prefix_ + dir,
                kPostRequest, {{kValue, value}});
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

template <typename Reply> Reply Client<Reply>::
Get(const std::string& key) {
    std::string ret;
    try {
        ret = handle_->Get(url_prefix_ + key);
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

template <typename Reply> Reply Client<Reply>::
GetAll(const std::string& key) {
    std::string ret;
    try {
        ret = handle_->Get(url_prefix_ + key + "?recursive=true");;
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

template <typename Reply> Reply Client<Reply>::
GetOrdered(const std::string& dir) {
    std::string ret;
    try {
        ret = handle_->Get(url_prefix_ + dir + std::string(kSortedSuffix));
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

template <typename Reply> Reply Client<Reply>::
Delete(const std::string& key) {
    std::string ret;
    try {
        ret = handle_->Set(
            url_prefix_ + key, kDeleteRequest, {});
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

template <typename Reply> Reply Client<Reply>::
AddDirectory(const std::string& dir) {
    std::string ret;
    try {
        ret = handle_->Set(url_prefix_ + dir, kPutRequest, {{kDir, "true"}});
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

template <typename Reply> Reply Client<Reply>::
AddDirectory(const std::string& dir, const TtlValue& ttl) {
    std::string ret;
    try {
        ret = handle_->Set(url_prefix_ + dir, kPutRequest,
            {
                {kDir, "true"},
                {kTttl, std::to_string(ttl)},
            });
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

template <typename Reply> Reply Client<Reply>::
UpdateDirectoryTtl(const std::string& dir, const TtlValue& ttl) {
    std::string ret;
    try {
        ret = handle_->Set(url_prefix_ + dir, kPutRequest,
            {
                {kDir, "true"},
                {kTttl, std::to_string(ttl)},
                {kPrevExist, "true"}
            });
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

template <typename Reply> Reply Client<Reply>::
DeleteDirectory(const std::string& dir, bool recursive) {
    std::ostringstream ostr;
    ostr << url_prefix_ + dir << "?dir=true";
    if (recursive)
        ostr << "&recursive=true";

    std::string ret;
    try {
        ret = handle_->Set(ostr.str(), kDeleteRequest, {});
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

template <typename Reply> Reply Client<Reply>::
CompareAndSwapIf(
    const std::string& key,
    const std::string& value,
    const std::string& prevValue) {
    std::ostringstream ostr;
    ostr << url_prefix_ << key << "?" << kPrevValue << "=" << prevValue;

    std::string ret;
    try {
        ret = handle_->Set(ostr.str(), kPutRequest, {{kValue, value}});
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

template <typename Reply> Reply Client<Reply>::
CompareAndSwapIf(
     const std::string& key,
     const std::string& value,
     const Index& prevIndex) {
    std::ostringstream ostr;
    ostr << url_prefix_ << key << "?" << kPrevIndex
         << "=" << std::to_string(prevIndex);

    std::string ret;
    try {
        ret = handle_->Set(ostr.str(), kPutRequest, {{kValue, value}});
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

template <typename Reply> Reply Client<Reply>::
CompareAndSwapIf(
     const std::string& key,
     const std::string& value,
     bool prevExist) {
    std::ostringstream ostr;
    ostr << url_prefix_ << key << "?" << kPrevExist
         << "=" << (prevExist ? "true" : "false"); 

    std::string ret;
    try {
        ret = handle_->Set(ostr.str(), kPutRequest, {{kValue, value}});
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

template <typename Reply> Reply Client<Reply>::
CompareAndDeleteIf(const std::string& key, const std::string& prevValue) {
    std::ostringstream ostr;
    ostr << url_prefix_ << key << "?" << kPrevValue << "=" << prevValue;

    std::string ret;
    try {
        ret = handle_->Set(ostr.str(), kDeleteRequest, {});
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

template <typename Reply> Reply Client<Reply>::
CompareAndDeleteIf(const std::string& key, const Index& prevIndex) {
    std::ostringstream ostr;
    ostr << url_prefix_ << key << "?" << kPrevIndex
         << "=" << std::to_string(prevIndex);

    std::string ret;
    try {
        ret = handle_->Set(ostr.str(), kDeleteRequest, {});
    } catch (const std::exception& e) {
        throw ClientException(e.what());
    }
    return _GetReply(ret);
}

//------------------------------ OPERATIONS ----------------------------------

template <typename Reply> Reply Client<Reply>::
_GetReply(const std::string& json) {
    if (enable_header_)
        return Reply (handle_->GetHeader(), json);
    return Reply(json);
}

} // namespace etcd

#endif // __ETCD_CLIENT_HPP_INCLUDED__

